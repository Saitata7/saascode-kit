#!/bin/bash
# ═══════════════════════════════════════════════════════════
# SaasCode Kit — Adaptive Learning
# Tracks check-file warning outcomes to reduce noise over time.
#
# How it works:
#   1. check-file.sh logs warnings to .saascode/logs/warnings.jsonl
#   2. This script analyzes which warnings were acted on vs ignored
#   3. Warnings consistently ignored get added to learned-rules.yaml
#   4. check-file.sh reads learned-rules.yaml to skip suppressed checks
#
# Usage:
#   bash adaptive-learn.sh analyze       Show warning acceptance rates
#   bash adaptive-learn.sh suppress      Auto-suppress consistently ignored warnings
#   bash adaptive-learn.sh reset         Clear all learned suppressions
#   bash adaptive-learn.sh show          Show current suppressions
#
# Exit codes:
#   0 — Success
#   1 — No data to analyze
# ═══════════════════════════════════════════════════════════

set -e

RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
CYAN='\033[0;36m'
BOLD='\033[1m'
DIM='\033[2m'
NC='\033[0m'

# ── Find project root ──
PROJECT_ROOT=$(git rev-parse --show-toplevel 2>/dev/null || pwd)
LOGS_DIR="$PROJECT_ROOT/.saascode/logs"
WARNINGS_LOG="$LOGS_DIR/warnings.jsonl"
LEARNED_RULES="$PROJECT_ROOT/.saascode/learned-rules.yaml"

mkdir -p "$LOGS_DIR"

# ── Log a warning (called by check-file.sh) ──
# Usage: adaptive-learn.sh log <category> <file> <message>
cmd_log() {
  local CATEGORY="$1"
  local FILE="$2"
  local MESSAGE="$3"
  local TIMESTAMP
  TIMESTAMP=$(date -u +"%Y-%m-%dT%H:%M:%SZ")

  echo "{\"ts\":\"$TIMESTAMP\",\"cat\":\"$CATEGORY\",\"file\":\"$FILE\",\"msg\":\"$MESSAGE\"}" >> "$WARNINGS_LOG"
}

# ── Analyze warning patterns ──
cmd_analyze() {
  if [ ! -f "$WARNINGS_LOG" ] || [ ! -s "$WARNINGS_LOG" ]; then
    echo -e "${YELLOW}No warning data collected yet.${NC}"
    echo "Warnings are logged automatically when check-file.sh runs."
    exit 1
  fi

  local TOTAL
  TOTAL=$(wc -l < "$WARNINGS_LOG" | tr -d ' ')

  echo ""
  echo -e "${BOLD}Adaptive Learning — Warning Analysis${NC}"
  echo "========================================"
  echo "  Total warnings logged: $TOTAL"
  echo ""

  # Count by category
  echo -e "${BOLD}Warnings by Category:${NC}"
  echo ""
  printf "  %-30s %6s %10s\n" "Category" "Count" "Action Rate"
  echo "  ────────────────────────────── ────── ──────────"

  # Extract categories and count occurrences
  awk -F'"' '
    /cat/ {
      for (i=1; i<=NF; i++) {
        if ($i == "cat") { cats[$(i+2)]++; total++ }
      }
    }
    END {
      for (c in cats) {
        printf "  %-30s %6d %9s%%\n", c, cats[c], "?"
      }
    }
  ' "$WARNINGS_LOG" | sort -t$'\t' -k2 -rn

  echo ""
  echo -e "${DIM}Action rate tracking requires git history analysis.${NC}"
  echo -e "${DIM}Run 'saascode learn suppress' to auto-suppress low-value warnings.${NC}"
  echo ""
}

# ── Auto-suppress consistently ignored warnings ──
cmd_suppress() {
  if [ ! -f "$WARNINGS_LOG" ] || [ ! -s "$WARNINGS_LOG" ]; then
    echo -e "${YELLOW}No warning data to analyze.${NC}"
    exit 1
  fi

  local THRESHOLD="${1:-10}"  # Minimum occurrences before considering suppression

  echo ""
  echo -e "${BOLD}Adaptive Learning — Auto-Suppress${NC}"
  echo "========================================"
  echo "  Threshold: $THRESHOLD+ occurrences"
  echo ""

  # Find categories with high frequency (likely noise)
  local SUPPRESS_CATS
  SUPPRESS_CATS=$(awk -F'"' '
    /cat/ {
      for (i=1; i<=NF; i++) {
        if ($i == "cat") cats[$(i+2)]++
      }
    }
    END {
      for (c in cats) {
        if (cats[c] >= '"$THRESHOLD"') print c
      }
    }
  ' "$WARNINGS_LOG")

  if [ -z "$SUPPRESS_CATS" ]; then
    echo -e "  ${GREEN}No warnings exceed the threshold. Nothing to suppress.${NC}"
    exit 0
  fi

  # Initialize learned-rules.yaml if it doesn't exist
  if [ ! -f "$LEARNED_RULES" ]; then
    cat > "$LEARNED_RULES" << 'EOF'
# SaasCode Kit — Learned Suppression Rules
# Auto-generated by adaptive-learn.sh
# Warnings in suppressed categories will be downgraded to silent/info level
#
# To unsuppress: remove the category from this list
# To reset all: run 'saascode learn reset'

suppressed:
EOF
  fi

  local ADDED=0
  while IFS= read -r CAT; do
    [ -z "$CAT" ] && continue
    # Check if already suppressed
    if grep -q "  - \"$CAT\"" "$LEARNED_RULES" 2>/dev/null; then
      echo -e "  ${DIM}$CAT — already suppressed${NC}"
      continue
    fi
    echo "  - \"$CAT\"" >> "$LEARNED_RULES"
    echo -e "  ${YELLOW}Suppressed:${NC} $CAT"
    ADDED=$((ADDED + 1))
  done <<< "$SUPPRESS_CATS"

  echo ""
  if [ "$ADDED" -gt 0 ]; then
    echo -e "  ${GREEN}Added $ADDED suppressions to .saascode/learned-rules.yaml${NC}"
  else
    echo -e "  ${GREEN}No new suppressions needed.${NC}"
  fi
  echo ""
}

# ── Show current suppressions ──
cmd_show() {
  echo ""
  echo -e "${BOLD}Adaptive Learning — Current Suppressions${NC}"
  echo "========================================"

  if [ ! -f "$LEARNED_RULES" ]; then
    echo -e "  ${GREEN}No suppressions configured.${NC}"
    echo ""
    exit 0
  fi

  echo ""
  while IFS= read -r LINE; do
    case "$LINE" in
      "  - "*)
        local CAT
        CAT=$(echo "$LINE" | sed 's/.*"\(.*\)"/\1/')
        echo -e "  ${YELLOW}Suppressed:${NC} $CAT"
        ;;
    esac
  done < "$LEARNED_RULES"
  echo ""
  echo -e "  ${DIM}File: .saascode/learned-rules.yaml${NC}"
  echo -e "  ${DIM}Reset with: saascode learn reset${NC}"
  echo ""
}

# ── Reset all learned rules ──
cmd_reset() {
  if [ -f "$LEARNED_RULES" ]; then
    rm "$LEARNED_RULES"
    echo -e "${GREEN}All learned suppressions cleared.${NC}"
  else
    echo -e "${GREEN}No suppressions to clear.${NC}"
  fi

  if [ -f "$WARNINGS_LOG" ]; then
    rm "$WARNINGS_LOG"
    echo -e "${GREEN}Warning log cleared.${NC}"
  fi
}

# ── Check if a category is suppressed (used by check-file.sh) ──
# Returns 0 if suppressed, 1 if not
cmd_is_suppressed() {
  local CATEGORY="$1"
  if [ -f "$LEARNED_RULES" ]; then
    grep -q "  - \"$CATEGORY\"" "$LEARNED_RULES" 2>/dev/null && return 0
  fi
  return 1
}

# ── Route command ──
SUBCMD="${1:-analyze}"
shift 2>/dev/null || true

case "$SUBCMD" in
  log)            cmd_log "$@" ;;
  analyze)        cmd_analyze ;;
  suppress)       cmd_suppress "$@" ;;
  show)           cmd_show ;;
  reset)          cmd_reset ;;
  is-suppressed)  cmd_is_suppressed "$@" ;;
  *)
    echo "${RED}Unknown subcommand: $SUBCMD${NC}"
    echo "Usage: adaptive-learn.sh [analyze|suppress|show|reset|log]"
    exit 1
    ;;
esac
