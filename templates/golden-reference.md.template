# Golden Reference â€” Copy These Patterns

> Auto-generated by SaasCode Kit from manifest.yaml
> These are the CORRECT patterns for this project. Copy them, don't invent new ones.

{{#if_eq auth.guard_pattern "decorator"}}
## Controller Pattern (Decorator-based Auth)

```typescript
import { Controller, Get, Post, Patch, Delete, Param, Body, UseGuards } from '@nestjs/common';
import { AuthGuard, TenantGuard, RolesGuard } from '../guards';
import { Roles, CurrentTenant, CurrentUser } from '../decorators';
import { Role } from '../enums';

@Controller('{{feature}}')
@UseGuards(AuthGuard, TenantGuard, RolesGuard)
export class {{Feature}}Controller {
  constructor(private readonly {{feature}}Service: {{Feature}}Service) {}

  @Get()
  @Roles(Role.OWNER, Role.ADMIN, Role.MEMBER)
  findAll(@CurrentTenant() {{tenancy.identifier}}: string) {
    return this.{{feature}}Service.findAll({{tenancy.identifier}});
  }

  @Get(':id')
  @Roles(Role.OWNER, Role.ADMIN, Role.MEMBER)
  findOne(@Param('id') id: string, @CurrentTenant() {{tenancy.identifier}}: string) {
    return this.{{feature}}Service.findOne(id, {{tenancy.identifier}});
  }

  @Post()
  @Roles(Role.OWNER, Role.ADMIN)
  create(@Body() dto: Create{{Feature}}Dto, @CurrentTenant() {{tenancy.identifier}}: string, @CurrentUser() userId: string) {
    return this.{{feature}}Service.create(dto, {{tenancy.identifier}}, userId);
  }

  @Patch(':id')
  @Roles(Role.OWNER, Role.ADMIN)
  update(@Param('id') id: string, @Body() dto: Update{{Feature}}Dto, @CurrentTenant() {{tenancy.identifier}}: string) {
    return this.{{feature}}Service.update(id, dto, {{tenancy.identifier}});
  }

  @Delete(':id')
  @Roles(Role.OWNER)
  remove(@Param('id') id: string, @CurrentTenant() {{tenancy.identifier}}: string) {
    return this.{{feature}}Service.remove(id, {{tenancy.identifier}});
  }
}
```
{{/if_eq}}

{{#if_eq auth.guard_pattern "middleware"}}
## Controller Pattern (Middleware-based Auth)

```typescript
import { Router } from 'express';
import { authenticate, resolveTenant, checkRole } from '../middleware';

const router = Router();

router.use(authenticate, resolveTenant);

router.get('/', checkRole('MEMBER'), async (req, res) => {
  const items = await {{feature}}Service.findAll(req.{{tenancy.identifier}});
  res.json({ success: true, data: items });
});

router.get('/:id', checkRole('MEMBER'), async (req, res) => {
  const item = await {{feature}}Service.findOne(req.params.id, req.{{tenancy.identifier}});
  if (!item) return res.status(404).json({ success: false, error: 'Not found' });
  res.json({ success: true, data: item });
});

router.post('/', checkRole('ADMIN'), async (req, res) => {
  const item = await {{feature}}Service.create(req.body, req.{{tenancy.identifier}}, req.userId);
  res.status(201).json({ success: true, data: item });
});

router.patch('/:id', checkRole('ADMIN'), async (req, res) => {
  const item = await {{feature}}Service.update(req.params.id, req.body, req.{{tenancy.identifier}});
  res.json({ success: true, data: item });
});

router.delete('/:id', checkRole('OWNER'), async (req, res) => {
  await {{feature}}Service.remove(req.params.id, req.{{tenancy.identifier}});
  res.json({ success: true, data: null });
});

export default router;
```
{{/if_eq}}

{{#if tenancy.enabled}}
## Service Pattern (Tenant-Scoped)

```typescript
// EVERY query MUST include {{tenancy.identifier}}
// EVERY findUnique MUST verify ownership after fetch

async findAll({{tenancy.identifier}}: string) {
  return this.prisma.{{feature}}.findMany({
    where: { {{tenancy.identifier}} },
    orderBy: { createdAt: 'desc' },
  });
}

async findOne(id: string, {{tenancy.identifier}}: string) {
  const item = await this.prisma.{{feature}}.findUnique({ where: { id } });
  if (!item || item.{{tenancy.identifier}} !== {{tenancy.identifier}}) {
    throw new NotFoundException();
  }
  return item;
}

async create(dto: Create{{Feature}}Dto, {{tenancy.identifier}}: string, userId: string) {
  return this.prisma.{{feature}}.create({
    data: { ...dto, {{tenancy.identifier}}, createdBy: userId },
  });
}

async update(id: string, dto: Update{{Feature}}Dto, {{tenancy.identifier}}: string) {
  const item = await this.findOne(id, {{tenancy.identifier}}); // ownership check
  return this.prisma.{{feature}}.update({
    where: { id: item.id },
    data: dto,
  });
}

async remove(id: string, {{tenancy.identifier}}: string) {
  const item = await this.findOne(id, {{tenancy.identifier}}); // ownership check
  return this.prisma.{{feature}}.delete({ where: { id: item.id } });
}
```
{{/if}}

## API Client Pattern

```typescript
// {{paths.api_client}}/{{feature}}.ts
// EVERY function here MUST have a matching backend endpoint

import { apiClient } from './client';
import type { {{Feature}}, Create{{Feature}}Dto, Update{{Feature}}Dto } from '@shared/types';

export const {{feature}}Api = {
  getAll: () =>
    apiClient.get<{ data: {{Feature}}[] }>('/{{feature}}'),

  getOne: (id: string) =>
    apiClient.get<{ data: {{Feature}} }>(`/{{feature}}/${id}`),

  create: (dto: Create{{Feature}}Dto) =>
    apiClient.post<{ data: {{Feature}} }>('/{{feature}}', dto),

  update: (id: string, dto: Update{{Feature}}Dto) =>
    apiClient.patch<{ data: {{Feature}} }>(`/{{feature}}/${id}`, dto),

  remove: (id: string) =>
    apiClient.delete<{ data: null }>(`/{{feature}}/${id}`),
};
```

## Page Pattern (3 Required States)

```tsx
// EVERY page MUST handle: loading, error, empty

export function {{Feature}}Page() {
  const { data, isLoading, error } = use{{Feature}}Query();

  if (isLoading) return <{{Feature}}Skeleton />;
  if (error) return <ErrorState message={error.message} onRetry={refetch} />;
  if (!data?.length) return <EmptyState title="No {{feature}} yet" action={<Create{{Feature}}Button />} />;

  return (
    <div>
      {data.map((item) => (
        <{{Feature}}Card key={item.id} item={item} />
      ))}
    </div>
  );
}
```

## Response Format

```typescript
// ALL API responses use this shape
interface ApiResponse<T> {
  success: boolean;
  data: T;
  error?: string;
  message?: string;
}
```

{{#if_eq stack.backend.orm "prisma"}}
## Schema Pattern

```prisma
model {{Feature}} {
  id          String   @id @default(uuid())
{{#if tenancy.enabled}}
  {{tenancy.identifier}} String
{{/if}}
  // data fields here
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  createdBy   String

{{#if tenancy.enabled}}
  @@index([{{tenancy.identifier}}])
{{/if}}
  @@map("{{feature}}")
}
```
{{/if_eq}}
